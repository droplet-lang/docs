---
sidebar_position: 5
---

# Virtual Machine Overview

The Droplet Virtual Machine (VM) executes **bytecode** generated by the Droplet compiler.  
It is designed as a **stack-based VM** to demonstrate how programming languages execute code.

---

## üîπ Components of the VM

1. **Instruction Stack**  
   - Stores temporary values and operands.  
   - Used for arithmetic, function calls, and expression evaluation.

2. **Call Frames**  
   - Each function call creates a **frame** on the stack.  
   - Stores local variables, instruction pointer, and return address.

3. **Heap**  
   - Stores dynamically allocated objects, strings, lists, and maps.  
   - Managed by a simple **garbage collector**.

4. **Native Function Registry**  
   - Built-in functions like `print`, `println`, `len`, `str` are registered here.  
   - VM calls these directly without bytecode instructions.

---

## üîÑ Execution Flow

1. Load `.dbc` bytecode file.  
2. Set instruction pointer to `main` function.  
3. Execute instructions sequentially:
   - Push/pop values on stack
   - Call functions (user-defined or native)
   - Perform arithmetic and comparisons
4. Allocate objects on the heap as needed.  
5. Clean up stack frames when functions return.  

---

## ‚úèÔ∏è Example Flow

Given this program:

```rust
fn main() {
    println("Hello VM!")
}
````

VM execution steps:

1. `main` function frame is created on stack.
2. `println("Hello VM!")` instruction pushes string onto stack.
3. Native function `println` is called.
4. Stack frame for `main` is removed after completion.

Output:

```
Hello VM!
```

---

## üß† Notes

* The VM uses a **stack-based architecture** for simplicity.
* Objects and dynamically-sized structures live on the heap.
* Native functions provide interaction with the host environment.
* This VM is **educational**, showing how programming languages execute code internally.
